"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubCommandManager = void 0;
const framework_1 = require("@sapphire/framework");
const SubCommandEntryCommand_1 = require("./SubCommandEntryCommand");
const SubCommandEntryMethod_1 = require("./SubCommandEntryMethod");
class SubCommandManager {
    constructor(entries) {
        Object.defineProperty(this, "entries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "default", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        for (const data of entries) {
            const value = this.resolve(data);
            const Ctor = SubCommandManager.handlers.get(value.type ?? 'method');
            if (!Ctor)
                throw new ReferenceError(`There is no sub command handler named '${value.type}' in 'SubCommandManager.handlers'.`);
            const entry = new Ctor(value);
            if (value.default) {
                if (this.default)
                    throw new Error(`There was already a default of '${this.default.input}', cannot add '${value.input}'.`);
                this.default = entry;
            }
            this.entries.push(entry);
        }
    }
    async messageRun(context) {
        // Pick one argument, then try to match a subcommand:
        context.args.save();
        const value = context.args.nextMaybe();
        if (value.exists) {
            for (const entry of this.entries) {
                if (await entry.match(value.value, context))
                    return entry.messageRun(context);
            }
        }
        // No subcommand matched, let's restore and try to run default, if any:
        context.args.restore();
        if (this.default)
            return this.default.messageRun(context);
        // No match and no subcommand, return an err:
        return (0, framework_1.err)(new framework_1.UserError({ identifier: "subCommandNoMatch" /* SubCommandNoMatch */, context }));
    }
    resolve(value) {
        if (typeof value !== 'string')
            return value;
        return { input: value, output: value, type: 'method' };
    }
}
exports.SubCommandManager = SubCommandManager;
Object.defineProperty(SubCommandManager, "handlers", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Map([
        ['command', SubCommandEntryCommand_1.SubCommandEntryCommand],
        ['method', SubCommandEntryMethod_1.SubCommandEntryMethod]
    ])
});
//# sourceMappingURL=SubCommandManager.js.map